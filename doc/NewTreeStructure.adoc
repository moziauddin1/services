= New tree structure
v1.0, June 2017
:imagesdir: resources/images/
:toc: left
:toclevels: 4
:toc-class: toc2
:icons: font
:iconfont-cdn: //cdnjs.cloudflare.com/ajax/libs/font-awesome/4.3.0/css/font-awesome.min.css
:stylesdir: resources/style/
:stylesheet: asciidoctor.css
:description: New tree structure documentation
:keywords: documentation, NSL, APNI, API, APC, tree
:links:
:numbered:

The current tree structure is over complicated and difficult to validate and maintain going forward. The reasons for this
are many, but basically come down to changing understanding of requirements.

I propose to scale back and simplify the structure used to store the trees and to only implement what is currently required,
then evolve the implementation as needed.

The main change in requirements is the idea of using a workspace, or draft tree, to do work. The workspace would then be
published as a new version. once a version is published it is immutable _except_ for minor typographical changes as determined
by policy.

****
This work is designed to make the tree easy to understand and reason about, and therefore

 * easier to change and maintain over time
 * improve performance
****

== Requirements

=== Major requirements:

 . The tree must store and display the parent child taxonomic relationship between names.
 . The tree must be versioned so that a citation (id) of a tree element must reproduce the tree as it was when it was
 viewed.
 . A link to an element on the tree should be able to identify the version of the tree and reproduce that version.
 . You should be able to link to a _version_ of the tree and get the current tree easily.
 . The tree must enforce strict rules about the placement of names on a tree.
 . Profile data including only Comment and Distribution data is to be stored in the tree structure.
 . Tree elements are pointers to an Instance as a representation of a Taxon Concept.
 . Tree elements can represent Accepted and Excluded items which need to be distinguished. This appears to be accepted
 and not accepted, but treated. The "Excluded" is a covering term of a number of reasons these names are not accepted
 (e.g. doubtful) but the distinction is not required. As such for now we can just indicate an element is Accepted or Not.
 . Easy to work with a version of the tree.
 . All common operations must be fast. You should be able to query the status of a name on the current tree without
 noticeable delay.
 . Editors should be able to work on a draft version of the tree without it being public, then publish it at a time of
 their choosing.
 . Versions should be released as a unit of work, collecting a set of changes together (policy).
 . The users need to be able to add a log entry describing the work done and referencing the documents that lead to the changes.
 . Multiple workspaces that can be merged over different time frames is a requirement.
 . It would be nice to be able to list and view older version of the tree and see what changed (diffing)
 . It would be nice to be able to archive older versions of the tree without breaking it.
 . we want to access the trees through RDF.

==== Uber trees

 . we must be able to create an "uber tree" from multiple sub trees.
 . The uber tree should be able to merge sub trees from multiple points - for example lichens have multiple connections
  the the fungi tree.
 . Uber tree elements need to Link back to source tree nodes if compositional.

according to https://www.environment.gov.au/science/abrs/publications/other/numbers-living-species/executive-summary[ABRS Numbers of Living Species in Australia and the World]
there are ~2million species in the world that we should aim to handle in an uber tree.

==== Use cases

 . creation of accepted taxonomic trees with strict hierarchical placement rules within a shard.
 . creation of a list of taxon concepts commonly (only) from family down, known as a checklist, from one or more shards.
 these trees may have more relaxed placement rules.
 . creation of composite (uber) trees made from multiple sub trees, such as accepted taxonomic trees from multiple shards

WARNING: We should take a closer look at the needs of List compilers and Tree composers to see if the difference in the
 set or requirements leads to different solutions for each.

==== Editors

Based on the above use cases, and current editor usage, it looks like we need two different editing pathways for trees.

  . In instance editor tree editing: Where the advanced editor can create specific taxonomic concepts for accepted trees
  in accordance with some authority such as CHAH.
  . A composition editor that can compose multiple trees into an uber tree, or create a checklist. This doesn't require the
  ability to edit instances, just choose concepts, or other tree elements/sections.

Perhaps the second, compositional, editor is logically broken into an uber tree manager and a checklist editor.

==== Search

We need to clearly define the  difference between the search on names (the APNI search) and the search requirements on
trees. At the moment there is confusion because some searches in the advanced search are mix tree and name concerns.

NOTE: Greg W. put this view forward too.

===== use cases

 . search a tree for names under a name and bring back the results displaying the apni or apc format output
   * search synonyms or accepted only
   * search based on native, naturalised, distribution or profile data.
   * further advanced filtering based on name/instance type, tags, author etc.
 . search a tree for names independent of any tree and display in APNI format - this may be an advanced search on name types
  tags, instance types, and may require knowledge of the Family.
 . Name check - a specific check against the accepted tree in a shard.

===== implementation (discussion)

Tree searches should be associated with the tree they are on because a tree may be separated from the name and instance
data it is pointing at. In the case of the uber trees they may be pointing to multiple shards.

Since trees contain the name and instance id, but not instance data a tree search may bring back a list of names that can
in turn fetch APNI or APC format data via the existing service API (much like the existing service search).

If we want to implement a closer coupled database implementation in the search we could link to multiple shard databases
to get the data. *I prefer the previous solution as it allows fully autonomous trees and lists to exist that just use
linked data.* However speed will need to be taken into account when looking at this, which means looking at if the service
APIs need improving or the solution is limited to direct database connections.

We need to carefully consider what is offered in search and how you discover what can be searched... initially of course
we are publicly offering only the APC as a cross shard search, and then moving up to NSL including AFD.

Trees that are linked to a shard, e.g. the Vascular APC tree, that have a database relationship to the name and instance
data in the shard can take advantage of joins for more complex queries.

Cross shard searching in general needs an API approach where an API (which could be just a database connection) is used
to collect data, then a map/reduce/sort approach is used to filter and sort results. The name paths and sort names will
help in collating and sorting results from multiple sources.

See https://www.anbg.gov.au/25jira/browse/NSL-2412[NSL-2312]

After discussion with Greg Whitbread and following from user feedback and experience the use of the name tree search may
be a reflection of the way we use the "product" concept and clarification of how the sets of data can be used, and what
they should be used for.

At the moment we try and describe this in the APNI and APC product descriptions.

APNI
****
The Australian Plant Name Index (APNI) is a tool for the botanical community that deals with plant names and their usage
in the scientific literature, whether as a current name or synonym. APNI does not recommend any particular taxonomy or
nomenclature. For a listing of currently accepted scientific names for the Australian vascular flora, please use the
Australian Plant Census (APC) link above.
****

APC
****
The Australian Plant Census (APC) is a list of the accepted scientific names for the Australian vascular flora, ferns,
gymnosperms, hornworts and liverworts, both native and introduced, and includes synonyms and misapplications for these
names. The APC covers all published scientific plant names used in an Australian context in the taxonomic literature,
but excludes taxa known only from cultivation in Australia. The taxonomy and nomenclature adopted for the APC are endorsed
by the Council of Heads of Australasian Herbaria (CHAH).
****

As Greg points out though, we don't limit the search, because people are asking "within" questions from APNI. This
question comes about because scientific names intrinsically, but unreliably, describe or imply rank and hierarchy
information, except where they don't.

It seems to me that we need to explicitly combine the name and taxonomy searches and express clearly what it is the
user is asking: for example "what is in the family Fabaceae according to Maberly" or "what is in the family Fabaceae
according to APC" and then we can do useful things like "compare the family Fabaceae according to Maberly and APC"

By combining we can ask questions like "What is not in APC but is in Maberly" so long as we can emphasize the context
of the APNI/NSL dataset.

=== Change over requirements:

 . We must maintain existing links to trees (APC) that have been used prior to this change. This means any links to
 existing nodes must resolve to the same instance data and position in the tree structure. The intrinsic data should not
 change, though extraneous data may be left out (broken links, some RDF identifiers that didn't lead to real data).
 . Editing the tree should work and be possible from the point of change over.

== Concept

The concept for the new structure is to remove the need for link objects and simply copy the list of tree elements for
each version of the tree. The Workspace is then a copy of the current tree that is then altered. When the workspace is
ready it is published as the latest version of the tree by making it the current version. A copy of the current version
is then made to create the new workspace version.

We track changes in the tree by maintaining a previous link that points to the tree_element in the previous version.

Versions are grouped by a tree_version which is associated with a tree. Tree_elements are associated with a tree_version.

 Tree <- [Tree_Versions] <- [Tree_Elements]

The tree holds a pointer to the current tree and a default workspace.

This concept trades storage efficiency for simplicity. Excessive numbers of versions could create a lot of copied
tree elements, but the workspace/publish model may also lead to a more structured release of versions
(e.g. once a Day/Week/Month) instead of on the fly changes.

=== Autonomous trees

Trees should be able to be autonomous from the shards. This means that database foreign keys to names and instances are
not enforced (i.e. no direct FK relationship). This means we need to rely on the link to identify the instances. It also
means that we want to copy the data required to ask questions of the tree into the tree structure as much as possible.

Whilst we will rely on the link to reference the data in the shards we will store the instance and name id (as a Long),
which means also that we need to store the source shard for the instance and name. If a placed name later becomes
de-duplicated we may have to update the id by using the mapper (rare).

=== Data usage vs speed

Copying the tree for every version is less space efficient than the current model, but affords many benefits. At the
current size of the APC tree 35k tree_elements are required for each copy.

NOTE: these are updated usage figures after spiking and importing actual data, the old guesstimate has been removed.

After doing the spike and adding in all the additional data to make the trees autonomous we can compare actual data sizes.

In APNI:

|===
| table | total size including inexes

| tree_node
| 282MB (inc 233MB index)

| tree_link
| 1394MB (inc 693MB index)

| tree_element (144 versions)
| 13GB (inc 2.7GB index)
|===

which makes the new tree structure  ~ 8 times the size of the old one without any real optimisation.
Extrapolating we get ~90MB per version.

[source]
.table-size.sql
----
SELECT
  *,
  pg_size_pretty(total_bytes) AS total,
  pg_size_pretty(index_bytes) AS INDEX,
  pg_size_pretty(toast_bytes) AS toast,
  pg_size_pretty(table_bytes) AS TABLE
FROM (
       SELECT
         *,
         total_bytes - index_bytes - COALESCE(toast_bytes, 0) AS table_bytes
       FROM (
              SELECT
                c.oid,
                nspname                               AS table_schema,
                relname                               AS TABLE_NAME,
                c.reltuples                           AS row_estimate,
                pg_total_relation_size(c.oid)         AS total_bytes,
                pg_indexes_size(c.oid)                AS index_bytes,
                pg_total_relation_size(reltoastrelid) AS toast_bytes
              FROM pg_class c
                LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
              WHERE relkind = 'r'
            ) a
     ) a;
----


We can copy all the current nodes _out of_ the database to a file and convert all the data to JSON in 0.2 seconds. Copying
tree elements to new tree elements should not take any longer (it should be quicker).

Also note that the new data structure allows us to partition and archive older versions should we need to.

Copying the 35k tree_elements to a workspace takes about 12.8 seconds:

 sql> INSERT INTO tree_element
 (tree_version_id,
  tree_element_id,
  lock_version,
  excluded,
  display_string,
  element_link,
  instance_id,
  instance_link,
  name_id,
  name_link,
  parent_version_id,
  parent_element_id,
  previous_version_id,
  previous_element_id,
  profile,
  rank_path,
  simple_name,
  tree_path,
  name_path,
  updated_at,
  updated_by)
   (SELECT
     139,
      tree_element_id,
      lock_version,
      excluded,
      display_string,
      '',
      instance_id,
      instance_link,
      name_id,
      name_link,
      139,
      parent_element_id,
      tree_version_id, -- previous version
      tree_element_id,
      profile,
      rank_path,
      simple_name,
      tree_path,
      name_path,
      updated_at,
      updated_by
     from tree_element where tree_version_id = 137
   )
 [2017-06-26 18:42:38] 35334 rows affected in 12s 802ms


VM info:
appsint1 24GB RAM (18GB used) 50GB space with ~27GB free for tomcat
pgsql-prod1-ibis.it.csiro.au 6GB RAM (5GB used) 
/dev/mapper/vg_data-lv_data        50G  981M   50G   2% /pg_data
/dev/mapper/vg_back-lv_back       100G   16G   85G  16% /pg_back
/dev/mapper/vg_tbl1-lv_tbl1       100G  8.3G   92G   9% /pg_tbl1
/dev/mapper/vg_xlog-lv_xlog        20G  257M   20G   2% /pg_xlog

=== Multiple workspaces

Because a workspace is just a copy of a version of the tree with pointers to the previous version of it's tree_elements,
we can implement a merge of the latest tree or a version (like a branch in GIT). A workspace or draft version of the tree
would reference the version it is a copy of and when you go to publish it, we check that the version of the current
tree has not changed. If it has you would need to merge the current version of the tree with your draft version. Where
there are conflicts, i.e. the current version  has changed a tree_element that you have also changed you need to resolve
the conflict by either accepting the current version, overwriting the current version with yours, or somehow merging the
changes. The workflow for a merge of conflicting changes is the trickiest bit.

Where different workspaces are working in different branches of the tree auto merging would be possible.

Multiple workspaces would make long running projects more feasible, e.g. adding a branch of orchids as a single update.

Talking to the current APC editors they considered the ability to have multiple workspaces and merging as something that
"was always a requirement, really"

=== Building new trees

A new tree starts with an initial draft version which can be

 . a copy of an existing tree
 . entirely new, adding elements to the root of the tree
 . made up of copies of portions of other trees, by copying from a node down and placing that section under a node in
 the draft.

Once the initial draft is ready to be made "public" it is published as the first version.

=== Tree paths

The current name tree path concept would be incorporated into the new tree_elements to provide a rapid way to display,
sort, and search for items under (subtending) an element (currently called a node). We can then remove name_tree_path as
an additional maintenance cost.

=== Immutable

The immutability of published versions (apart from typographical fixes, mainly in the names/references) means that we can
use de-normalisation of data to increase efficiency in display and queries. For example, storing a precomposed display
string for the tree, name and rank information (see name_tree_paths rank path and name path). This also makes trees largely
stand alone when it comes to queries.

****
For example you could search *just the tree elements* for a name string % abru% in family
Fabaceae of rank species that are native to WA.
****

This will greatly improve the speed and simplicity of searches, especially given the right indexes.

Since links are also immutable they can also be stored to reduce round trips to the mapper.

=== Synonyms

To further make trees autonomous we need to store the synonyms of the name in the tree element data. This can be achieved
by storing a names string, similar to the name path, that contains all the synonyms of the name separated by a pipe.

 e.g.
 |Acacia mucronata subsp. mucronata|Acacia mucronata var. linearis|Acacia mucronata var. mucronata|Racosperma mucronatum subsp. mucronatum

This means you can do a search for a name on a tree including the synonyms by doing:

 select * from tree_element where names like '%|Acacia mucronata var. linearis%';

You can even display the synonyms without further query.

NOTE: Greg W says to make the search useful we'll need to store the type of synonym as well. This could be stored
in a jsonb field so we retain the speed of the trigram indexed synonyms search with the ability to filter on instance type.

To do a synonym search on a JSONB field and take advantage of gin indexing we need to carefully structure the JSON data
around a common search. This probably means grouping the synonyms into relationship types e.g.

  {
    nomenclatural: [],
    taxonomic: [],
    misapplied: []
  }

=== Profile data

The Profile data will be stored as a JSON object/document field in the tree_element. This allows arbitrary extension of the
profile data to be stored. It also provides a consistent versioned view of the Profile data.

==== Comments

Comments will be stored as a text comment field in the JSON profile data.

==== Distribution

Distribution data is currently just unstructured and unvalidated text. However a *lot* of the requests for information
rely on the distribution data, and the correct interpretation of that data. Since distribution data is part of the
profile data requirement now is a good time to tackle this.

To this end we will make the distribution profile data a JSON object in the profile field containing pointers to
distribution data combinations. Distribution data combinations consist of a region and a set of flags in a legal
combination much the same way as name_status is set up. We use a JSON field because there is a variable number of regions
that can be assigned to a concept (tree_element) and we don't want to make outward pointing join tables to tree_elements.

This design helps keep trees stand alone, while linking back to distribution combinations and allowing the distribution
definition to be extended, while providing the editor with a configurable set of valid profile combinations.

The Distribution field of the profile will contain a list of JSON object representations of the distribution combinations
including the id of the combination for update purposes.

=== Archiving

The data structure allows for archiving of versions by moving/exporting a tree version. The structure keeps all the data
contained in the tree itself. Versions are immutable or read only, and self contained. Operations that need to interact
with the tree are limited to the workspaces/drafts, and perhaps some advanced search operations on the current version.

By storing the Name, display string, Rank Path, and links on the tree, older versions can be displayed and queried without
referring to the rest of the NSL database, making it possible to have a service which can display the tree as it was from
archived version in a different database.

This also means exporting a tree version provides 'all' the data needed to describe the tree.

=== Composite keys for tree_elements

It would be worth looking at using composite keys for tree_elements made up of the tree_version id and the tree_element id
that way we can copy the tree_elements and just change the version number.

The advantages of this are:

 . dramatically reduces the number of id's we have to generate out of the globally unique ID pool
 . intrinsically tracks nodes from one version to the next
 . simplifies the copy process a little
 . may help in diffing trees ( grab all the tree_elements with the same id across versions )
 . lets you very quickly find what an old version of a tree_element looks like now and ask questions like is this in
 the current version without any tree walks.

Disadvantages are:

 . Looking up by id always requires the version
 . slightly trickier ORM mapping

I think just advantage 1 outweighs the disadvantages because 100 x 35000 = 3,500,000 new IDs per year when the majority of
the data doesn't change. The rest of the advantages come down to speed and efficiency.

=== Auditing

A single updated by and updated at field is required in the tree_element since changes are versioned. Once again the idea
of this being copied makes the versions self contained at the expense of space.

== Transition

We will identify and replace the existing service endpoints for the Instance Editor to maintain functionality with the
change over. The tree editor functionality will need to be changed or incorporated into the Instance Editor. This work
needs to happen anyway.

=== Existing history

There are currently:

 * 114k current APC nodes, including 35k taxon nodes and 79k value nodes.
 * 365k taxon nodes for any tree (including the APNI name tree)
 * 7M links.
 * 2995 versioned changes to the APC tree

The version changes date back to 2012-02-09 via the APC import. Greg Whitbread has suggested that we could discard all the
historical changes up to a point, and considering no one would have relevant links that are currently supported.

Looking in the mapper we only have mapped these older URI:

 * apni.name/
 * apni.publication/
 * apni.reference/
 * apni.taxon/

None of which refer to tree information, or nodes.

We currently map 63k node objects in the mapper across all trees, 48k nodes in apni (vascular shard).

There are 315k taxon nodes out of 365k (apni shard) that are _not_ in the mapper and therefore have never been referenced.
There are 67k APC taxon nodes out of 115k APC taxon nodes that are _not_ in the mapper and so haven't been referenced.
There are only 5 nodes in the current APC tree that are not in the mapper.

How much history should we keep? We can import from 2016 and delete history later.

=== option 1

Based on the above stats we should be able to work out which of the 2995 versions of the tree we have currently are in
the mapper and and just replicate those versions to maintain the mapped links. Doable, but tricky.

*NOTE* it's possible that we have shared links to nodes that are _not_ in the mapper via the APC taxon exports. These
links are created in SQL, but may not have been created in the mapper because no one has referred to them via the services.
We could fix this by adding all nodes since the APC taxon exports started being used (with node links). There are 5 nodes
in the current APC tree that are not in the mapper.

=== option 2

Draw a line in the sand, then group changes. We can be sure that no links to the tree exist before the NSL was launched,
so we can ignore all versions before January 2015 (leaving us with 2643 versions). Then group versions into monthly
releases and point all node links in that month to the final version of the node for that month. This brings it down to
around 30 versions.

This somewhat breaks the contract that what was cited is what we get back, however the number of citations where the
changes incurred matter would, I guess, be approaching zero? I say that because by and large the changes per version are
for a single item, so while december 2015 saw 132 versions each one was for a single name, e.g.

.version changes
|===
|note |time stamp

|update name 5416769|2015-12-23 09:34:44.212000 +11:00
|update name 81345|2015-12-23 09:33:52.836000 +11:00
|update name 5417736|2015-12-23 09:32:46.223000 +11:00
|update name 5419222|2015-12-23 09:31:40.348000 +11:00
|update name 80372|2015-12-23 09:29:25.683000 +11:00
|add name 80912 to name 80855|2015-12-23 08:49:16.608000 +11:00
|add name 80899 to name 80855|2015-12-23 08:48:29.840000 +11:00
|add name 80878 to name 80855|2015-12-23 08:47:15.710000 +11:00
|===

Take these changes adding excluded names to Correa pulchella J.B.Mackay ex Sweet which is this node
https://biodiversity.org.au/nsl/services/node/apni/5424450 at 2015-12-23 08:49:16.608000 +11:00 but was a different
node 3 minutes earlier. The reality is that these changes were meant to be done as a batch and should only have been
published once.

==== option 2a

We could modify this option to group changes in a day to a single version, in which case I doubt anyone would notice.
This would not dramatically increase the number of versions saved as tree work seems to be limited to a few days a month
which comes out as a total of 206 versions from 2015-01-01.

=== Declared BTs

Declared BT tree_elements will be removed from history and where we can the excluded names attached to the BT will
be linked ot the BTs parent directly. Most of the time this will mean the top of the tree. This will create a consistent
tree in the history.

=== Existing links

NOTE: A link to a node in the old structure only gives you the structure *below* it as it was when you took the link
unless you took a link to a changed node further up the tree, or the top node. Although it is possible to find the
version of the tree you were looking at it was *not* intrinsic in the link.

We can take existing published links and forward them to new links. Due to history only being maintained in node links
below that node we need node links to point to the latest version that has that node id (now the tree_element_id).

****
https://biodiversity.org.au/nsl/services/node/apni/7845073 would point to tree_element.tree_element_id = 7845073
with the latest tree_version_id (137 in my spike):

 select name_path, simple_name from tree_element where tree_version_id = 137 and tree_element_id = 7845073;

|===
|name_path|simple_name
|/Plantae/Charophyta/Equisetopsida/Magnoliidae/Asteranae/Gentianales/Rubiaceae/Spermacoce | Spermacoce
|===
****

We can update the mapper to make these links work correctly (that's what the mapper is for).

==== new links

We need to be able to encode the version into the tree links since tree_element uses a composite key.

Links currently are structured as .../object/namespace/number, e.g. node/apni/7845073, where the namespace so far
has been directly related to the shard. Trees are meant to be above/separate to shards, so perhaps we should move to
storing the shard specifically in the identity structure in the mapper (it's more of a system identifier). This way
we can use the namespace as intended and have tree element links like:

 .../tree/137/7845073  i.e. effectively tree/version/element

this lets us map any tree version to any shard/uber service directly.

This change involves changing the mapper code to include a system identifier in "identifiers". This means we have to
put in place changes to the services to ask the mapper to set the system, which we could default to the shard/namespace
in the identifier.

This URL scheme is useful for debugging.

NOTE: Previously links were only created in the mapper when they were requested by the services - This was not intended
 to be the default way to make links, but... So when a workspace is published we should do a bulk add of identifiers to
 the mapper. We need to add a bulk add api call on the mapper.

The mapper currently handles around 1.15 million identities without problem, and is designed to scale out via load
balancing if needed.

=== RDF

We will need to map the new tree structure in joseki. There is a project called nsl-data, that is in the old git
repository. The nsl-data/src/apni.ttl file contains around 400 lines of mapping config (lines 2057 - 2457) which will
need to be reconfigured and deployed.

Currently the RDF services are apparently largely unused, so we should be able to re-map to a structure that makes
sense.

=== Uber trees

The new structure caters for uber trees by easily allowing trees to be copied and providing very fast mechanisms for
search and display. Two million records is certainly not excessive to copy or refer to. It is not expected that people
will edit the uber tree directly so workspace versions would not normally be required.

We need to provide a mechanism to describe and build an uber tree that potentially watches the component trees to build
current uber tree.

Two million record tree would be expected to take up around 285MB based on the estimated data usage figures quoted above
for 35k names.

doing a select on 4 819 443 tree_elements and ordering by name_path on my local machine took 3m 12s

 select * from tree_element order by name_path;
 2000 rows retrieved starting from 1 in 3m 12s 448ms (execution: 3m 11s 788ms, fetching: 660ms)

after optimising postgresql this came down to 1m 40s.

With a trigram index on name_path a search for everything under Eucalyptus on 4.8M tree_elements (159213 results 2000 fetched)
takes ~5 seconds.

 sql> select * from tree_element where name_path like '%/Eucalyptus/%' order by name_path
 [2017-06-26 17:02:47] 2000 rows retrieved starting from 1 in 4s 910ms (execution: 4s 579ms, fetching: 331ms)

On about 2M elements it takes 2.2s indicating the time taken for these queries is linear with number of records.

  sql> select * from tree_element where tree_version_id > 80 and name_path like '%/Eucalyptus/%' order by name_path
  [2017-06-26 17:07:46] 2000 rows retrieved starting from 1 in 2s 271ms (execution: 2s 35ms, fetching: 236ms)

This also indicates more machine grunt may improve performance. (After optimising postgresql this came down to 1.48s)

****
My local machine is an i7-4820K 3.70GHz CPU x 4, 32GB machine with a 500GB Samsung SSD. Postgresql had not been optimised
for this machine yet.
****

Copying 2 million tree_elements into a new table takes around 9.6s

 sql> select * into new_tree_elements from tree_element where tree_version_id > 80
 [2017-06-26 17:37:30] completed in 9s 618ms


Given it takes about 12 seconds to copy/insert 35k tree_elements into the tree_elements table to make a workspace
it should take around 11 minutes to copy an entire 2 million element tree. We shouldn't have to copy the entire uber
tree of this size very often.

== What it looks like

image::new-tree-overview.svg[]

== The model

image::new-tree-structure.svg[]

== User impact of change over

Currently in production:

 * a taxon can be added or removed from a tree.
 * the status of the taxon can be changed from accepted to excluded.
 * the comment and distribution values on the tree can be updated, but are not used as instance notes are used instead.

Synonymy does not affect the tree structure as such, as that is related to the concepts that are placed on the tree only.
There is no current process to determine if changes to synonymy of taxon concepts (instances) affect the tree, in terms
of the rules governing placements.

Placement rules are currently poorly implemented and incomplete.

In the change over the initial goal will be to replace the existing functionality. We should be able to do this without
major impact or change.

== Amount of work

There main functional areas affected by this change:

 . Search
 . Display
 . Editing

We would also need to factor out NameTreePath as it is replaced by the new TreeElement and the APNI name tree.

I'm guestimating the amount of work to be around 340 hours in total, which depending on other work could be completed
in 8 weeks.

=== APNI Name Tree

Now would be the right time to replace the APNI name tree if we're going to do that. JIRA NSL-2304 discusses the issues
around the name tree being replaced. There is definitely a current need for a tree structure that caters for names that
aren't in the APC/taxonomic tree.

The solution suggested in NSL-2304 is to replace Name.sortName with a tree path as per the tree_element and existing
name_tree_path, and putting the "agreed" family of a name in the name where that name is below family. Name id path
would be a logical addition to speed up any other name path operations, but we may say
https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it[YAGNI] on this initially.

To do this we would do this (in order):

. copy the APC name path to all names in APC
. copy the APC name path to all synonyms of names on the tree
. follow name.parent up the tree for names not in APC till we reach a name in APC to build their path.

In the last step we can stop once we hit a name with a name path, which makes this more of a functional step.

This still means editors should put the immediate parent of a name in, not the "Name parent" as we're still using the
name tree as a filler for what isn't in APC.

=== Search and display

==== Services

In the current services we use a search including the tree_nodes to determine if a name is on a tree and where it is
ranked on that tree. We also look to see if a name is in APC to display an APC tick. This has been generalised somewhat
to allow different "accepted" trees.

We need to refactor:

|===
|work| notes| effort
| search and APC/APNIFormat outputs.| -| 20h
| tree path code to use the tree_element | will mostly be deleting code that keeps up with tree_node changes| 20h
| The APNI name tree needs to be replaced | just use the name parent, and make sure Family comes from the accepted
tree only. Extra time allowed for implementation discussion.|40h
| tree services API | most of it is deleted.| 40h
| Tree object representation| -|20h
| flat view taxon and name exports | rework the view| 10h
| test infrastructure and tests| -| 30h
|| -|180h
|===

Obviously the existing tree structure is used extensively in the services for the "tree services", but most of that will
just go and be replaced with a much simpler set of code. The search service and APNI/APC format out put are the only
other places that use them along with name_tree_path.

===== Objects representation in HTML/JSON

Currently the tree nodes are modeled with and output object which in html looks like
https://biodiversity.org.au/nsl/services/node/apni/9159708

The JSON version exposes too much of the tree infrastructure by using terminology like "subnodes", links and some random
RDF stuff.

https://biodiversity.org.au/nsl/services/node/apni/9159708.json

Most of the following snippet is useless to anyone consuming the data.

[source,javascript]
.node_snippet.js
----
{
    "class": "au.org.biodiversity.nsl.Link",
    "typeUri": {
        "idPart": "btOf",
        "nsPart": "apc-voc",
        "uri": "http://biodiversity.org.au/voc/apc/APC#btOf",
        "uriEncoded": "http%3A%2F%2Fbiodiversity.org.au%2Fvoc%2Fapc%2FAPC%23btOf",
        "qname": "apc-voc:btOf",
        "css": "apc-voc bt-of"
    },
    "subNode": {
        "class": "au.org.biodiversity.nsl.Node",
        "_links": {
            "permalink": {
                "link": "https://id.biodiversity.org.au/node/apni/9159707",
                "preferred": true,
                "resources": 1
            }
        },
        "id": 9159707,
        "type": "T",
        "typeUri": {
            "idPart": "ApcConcept",
            "nsPart": "apc-voc",
            "uri": "http://biodiversity.org.au/voc/apc/APC#ApcConcept",
            "uriEncoded": "http%3A%2F%2Fbiodiversity.org.au%2Fvoc%2Fapc%2FAPC%23ApcConcept",
            "qname": "apc-voc:ApcConcept",
            "css": "apc-voc apc-concept"
        }
    },
    "linkSeq": 1,
    "versioningMethod": {
        "enumType": "au.org.biodiversity.nsl.VersioningMethod",
        "name": "V"
    },
    "isSynthetic": true
},

----

We'll replace the html page with something very similar for now and completely restructure the JSON output to better
represent the taxon in the context of the tree.

==== Editor

|===
|work| notes| effort
|convert views| mostly simple changes but need to handle node type| 10h
|refactor models| the DB models need to be replaced with new models hopefully returning only relevant data| 40h
|refactor the tree editing tab| with the refactoring of the tree edit service end points this should be a minimal change
only replacing some of the reference keys like the voc:AcpComment stuff.| 40h
|||90h
|===

The editor uses views to check if a name is currently accepted:

 * accepted_name_vw
 * accepted_synonym_vw

We would need to change code around type_code which relates directly to tree_node.type_uri_id_part.

The editor also models

 * TreeArrangement
 * TreeLink
 * TreeNode
 * TreeUriNs
 * TreeValueUri
 * AcceptedConcept
 * AcceptedInSomeWay

which would all need refactoring for usage.

There are two different editors for the tree in the instance editor, the current AngularJS based one can be removed
completely and be replaced with the workspace based one that uses the following service end points:

 * treeEdit/updateValue
 * treeEdit/placeNameOnTree
 * treeEdit/removeNameFromTree

==== New tree editor

|===
|work| notes| effort
|Add admin tasks to admin pages| This should be a straightforward form| 20h
|Add a tree view| This should already be part of the new tree_element object display replacing the node object| included
|re work validation code| see services | included
|||20h
|===

This editor needs to be incorporated in the instance editor. The new structure will make this easier, but this is
possibly not required in the first iteration of this change.

Basically we need to be able to create trees and workspaces and publish or delete a workspace. Create and delete are
part of the existing API on the services.

We will make the basic tree administration part of the existing services and incorporate the editing into the instance
editor. We will develop a tree view for both the editor and services - where the editor view will allow access to
instance editing etc.

We will re-implement the validation code on the new tree structure as a callable service, and as part of the placement
actions.

==== New search

|===
|work| notes| effort
|convert views| mostly simple changes but need to handle node type| 10h
|refactor models| the DB models need to be replaced with new models hopefully returning only relevant data| 40h
|||50h
|===

The new search app uses the following views:

  * accepted_name_vw
  * accepted_synonym_vw
  * instance_resource_vw
  * name_instance_vw
  * name_or_synonym_vw

It models:

 * TreeArrangement
 * TreeNode

== Other stuff
At the moment the name tree has namespaces and the lichen name tree has 31 Fungi name spaced names. This doens't work at
the moment as a tree can only have one name space. I have changed the lichen names to all have the same namespace (Lichen)
so that the current name tree works kind of....

But this is going to bring up a problem we'll have to deal with where we have intersecting trees.

== Query Examples

This section is for documenting some query examples using the new tree structure.

=== Search for synonyms of a type in a tree

[source,sql]
.search-synonyms.sql
----
SELECT
  el.name_id,
  el.simple_name,
  tax_syn,
  synonyms ->> tax_syn,
  rank.name,
  type.name,
  el.names,
  el.name_path
FROM tree_element el
  JOIN name n ON el.name_id = n.id
  JOIN name_rank rank ON n.name_rank_id = rank.id
  JOIN name_type type ON n.name_type_id = type.id
  ,
      jsonb_object_keys(synonyms) AS tax_syn
WHERE tree_version_id = 144
      AND el.names like '%Billardiera b%'
      AND type.scientific
      AND tax_syn ILIKE 'Billardiera b%'
      AND synonyms -> tax_syn ->> 'type' = 'taxonomic synonym'
ORDER BY el.name_path;
----

|===
| name_id | simple_name | tax_syn | syn_data | rank | type| name_path
|55543|Billardiera scandens|Billardiera brachyantha|"{""type"": ""taxonomic synonym"", ""name_id"": 230111}"|Species|scientific| Plantae Charophyta Equisetopsida Magnoliidae Asteranae Apiales Pittosporaceae Billardiera scandens
|55543|Billardiera scandens|Billardiera brachyantha var. brachyantha|"{""type"": ""taxonomic synonym"", ""name_id"": 55168}"|Species|scientific|Plantae Charophyta Equisetopsida Magnoliidae Asteranae Apiales Pittosporaceae Billardiera scandens
|84869|Marianthus bicolor|Billardiera bicolor var. lineata|"{""type"": ""taxonomic synonym"", ""name_id"": 55149}"|Species|scientific|Plantae Charophyta Equisetopsida Magnoliidae Asteranae Apiales Pittosporaceae Marianthus bicolor

|===

=== To sum the total data size of the tree_element table

[source]
.sum_tree_element.sql
----
select
  pg_size_pretty(sum(pg_column_size(tree_version_id))) as tree_version_id_size,
  pg_size_pretty(sum(pg_column_size(tree_element_id))) as tree_element_id_size,
  pg_size_pretty(sum(pg_column_size(lock_version))) as lock_version_size,
  pg_size_pretty(sum(pg_column_size(display_string))) as display_string_size,
  pg_size_pretty(sum(pg_column_size(element_link))) as element_link_size,
  pg_size_pretty(sum(pg_column_size(excluded))) as excluded_size,
  pg_size_pretty(sum(pg_column_size(instance_id))) as instance_id_size,
  pg_size_pretty(sum(pg_column_size(instance_link))) as instance_link_size,
  pg_size_pretty(sum(pg_column_size(name_id))) as name_id_size,
  pg_size_pretty(sum(pg_column_size(name_link))) as name_link_size,
  pg_size_pretty(sum(pg_column_size(name_path))) as name_path_size,
  pg_size_pretty(sum(pg_column_size(names))) as names_size,
  pg_size_pretty(sum(pg_column_size(parent_version_id))) as parent_version_id_size,
  pg_size_pretty(sum(pg_column_size(parent_element_id))) as parent_element_id_size,
  pg_size_pretty(sum(pg_column_size(previous_version_id))) as previous_version_id_size,
  pg_size_pretty(sum(pg_column_size(previous_element_id))) as previous_element_id_size,
  pg_size_pretty(sum(pg_column_size(profile))) as profile_size,
  pg_size_pretty(sum(pg_column_size(rank_path))) as rank_path_size,
  pg_size_pretty(sum(pg_column_size(simple_name))) as simple_name_size,
  pg_size_pretty(sum(pg_column_size(source_element_link))) as source_element_link_size,
  pg_size_pretty(sum(pg_column_size(source_shard))) as source_shard_size,
  pg_size_pretty(sum(pg_column_size(synonyms))) as synonyms_size,
  pg_size_pretty(sum(pg_column_size(tree_path))) as tree_path_size,
  pg_size_pretty(sum(pg_column_size(updated_at))) as updated_at_size,
  pg_size_pretty(sum(pg_column_size(updated_by))) as updated_by_size
  from tree_element;
----

=== To find the total used sizes of tables in the database

[source]
.table_size.sql
----
SELECT
  *,
  pg_size_pretty(total_bytes) AS total,
  pg_size_pretty(index_bytes) AS INDEX,
  pg_size_pretty(toast_bytes) AS toast,
  pg_size_pretty(table_bytes) AS TABLE
FROM (
       SELECT
         *,
         total_bytes - index_bytes - COALESCE(toast_bytes, 0) AS table_bytes
       FROM (
              SELECT
                c.oid,
                nspname                               AS table_schema,
                relname                               AS TABLE_NAME,
                c.reltuples                           AS row_estimate,
                pg_total_relation_size(c.oid)         AS total_bytes,
                pg_indexes_size(c.oid)                AS index_bytes,
                pg_total_relation_size(reltoastrelid) AS toast_bytes
              FROM pg_class c
                LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
              WHERE relkind = 'r' and nspname = 'public'
            ) a
     ) a;
----

== Placement Rules

This is an interpretation of the results of the discussion at https://www.anbg.gov.au/ibis25/display/NSL/Tree+Monitor+Functionality
regarding the placement rules.

This is from the point of view of attempting to place an instance on a version of a tree. The version of the tree must
be consistent within these rules. We take it that an Instance == Concept == Taxon == Taxon concept. The Instance being
placed as already been chosen appropriately in an editor.

WARNING: we need to look at the difference between validating a placement, before it's been placed and validating a
whole tree that already has been created.

=== The Taxon should not already be on the tree
=== A Taxon's Name can not be in the tree as an accepted name more than once
=== The Taxon's Name Rank must be below the parent taxon's rank
=== A relationship instance can't be put on the tree
=== Polynomial names must be a child of the name parent except excluded names

e.g. Doodia caudata must be placed under Doodia

=== Hybrid names must be a child of the first hybrid name

e.g.  Blechnum cartilagineum Sw. x Doodia media R.Br. must be placed under Blechnum cartilagineum

=== An accepted name can't be placed under an excluded name

All names above an accepted name must also be accepted.

=== illegal and illegitimate names *should not* be placed on the tree

This is a warning only because there are illegitimate names used in APC because a phrase name would have to be created.


=== A Taxon's Name or Synonyms can only be in the tree once.

checking for synonyms needs to be done from a point of view. For example with Ficus virens
(see https://biodiversity.org.au/nsl/services/search?product=APC&tree.id=1133571&name=Ficus+virens&inc._scientific=&inc.scientific=on&inc._cultivar=&inc._other=&max=100&display=apc&search=true)

Ficus virens var. sublanceolata (Miq.) Corner is a synonym of Ficus virens according to CHAH 2005, but not according to
CHAH 2016 which has them as distinct taxa (so they can both be accepted). The existing code for findSynonymOfInstance
checks if a placed instance is cited by the instance you wish to place in any reference (other relationship instance).
If you try to place Ficus virens Aiton (CHAH 2016) it will bring up the CHAH 2005 instance, which isn't relevant because
you're view (sensu)  is CHAH 2016.

So we should check synonomy from the point of view of the taxa being placed and then the already placed taxa back to the
taxa being placed, e.g. from Ficus virens var. sublanceolata

To warn on taxonomic synonyms we need to check the name of the instance. For example if you try to place Woodwardia Sm.
under Blechnaceae using Mueller, F.J.H. von (1882), Systematic Census of Australian Plants which considers Doodia R.Br.
to be a Synonym, but the instance of Doodia on the tree does not consider woodwardia a taxonmic synonym you won't see
the apparently obvious conflict in this placement because the cited instance is not on the tree. So if the instance being
placed cites a Name as being a synonym we should probably warn the user.

* relationship instances can't be placed on the accepted tree
* misapplication synonyms can be ignored.
* warn if pro. parte synonyms exist elsewhere in the current tree

==== Implementation within the tree

The Synonyms field in the Tree Element shows the synonym name and the type. We need to use the synonyms JSON structure to
determine if the name exists as a synonym in the context of what is on the tree currently and that no synonyms of the taxon
being placed are on the tree.

So if we try and place 'Ficus cunninghami' we might use...

[source]
.find-synonym-of.sql
----
SELECT
  el.name_id,
  el.simple_name,
  tax_syn,
  synonyms ->> tax_syn,
  el.names,
  el.name_path
FROM tree_element el
  JOIN name n ON el.name_id = n.id,
      jsonb_object_keys(synonyms) AS tax_syn
WHERE tree_version_id = 146
      AND el.names like '%|Ficus cunninghami|%'
      AND synonyms -> tax_syn ->> 'type' !~ '.*(misapp|pro parte).*'
  and tax_syn = 'Ficus cunninghami'
----

Which takes around 60-70ms to find Ficus virens. Note the LIKE on el.names limits the search quickly before using the slower
jsonb queries, and is quicker than the equivalent regex.

[source]
.explain
----
Nested Loop  (cost=0.98..127531.08 rows=3 width=342)
  ->  Nested Loop  (cost=0.98..127525.04 rows=3 width=310)
        ->  Index Scan using tree_element_pkey on tree_element el  (cost=0.56..127511.69 rows=3 width=310)
              Index Cond: (tree_version_id = 146)
              Filter: (names ~~ '%|Ficus cunninghami|%'::text)
        ->  Index Only Scan using name_pkey on name n  (cost=0.42..4.44 rows=1 width=8)
              Index Cond: (id = el.name_id)
  ->  Function Scan on jsonb_object_keys tax_syn  (cost=0.00..2.00 rows=1 width=32)
        Filter: ((tax_syn = 'Ficus cunninghami'::text) AND (((el.synonyms -> tax_syn) ->> 'type'::text) !~ '.*(misapp|pro parte).*'::text))
----

if we repeat that search for all the names in the el.names string for the name we're trying to place, then we would have
found all matching names both ways.

So for example we can find all the clashing synonyms for an instance using:

[source]
.find_synonyms
----
SELECT
  el.name_id,
  el.simple_name,
  tax_syn,
  synonyms -> tax_syn ->> 'type' as syn_type,
  synonyms -> tax_syn ->> 'name_id' as syn_id
FROM tree_element el
  JOIN name n ON el.name_id = n.id,
      jsonb_object_keys(synonyms) AS tax_syn
WHERE tree_version_id = 146
      AND synonyms -> tax_syn ->> 'type' !~ '.*(misapp|pro parte).*'
  and tax_syn in (select synonym.simple_name as sn
from Instance s join instance_type it on s.instance_type_id = it.id,
  Name synonym
where s.cited_by_id = :instance_id_to_place
      and synonym.id = s.name_id
  and it.misapplied = FALSE
  and it.pro_parte = FALSE
);
----

Using the above if we try and place Ficus virens var. sublanceolata sensu Jacobs & Packard (1981) plants of NSW instance 692695
we get the results:

|===
|name_id|simple_name|tax_syn|syn_type|syn_id

|75398|Ficus virens|Ficus cunninghamii|taxonomic synonym|90744
|75398|Ficus virens|Ficus infectoria var. cunninghamii|taxonomic synonym|91343
|===

==== Checking the validity of an existing tree

Check all names in the tree for synonyms of that name in the tree:

[source]
.findSynonyms in tree
----
SELECT
  e1.simple_name                    AS name1,
  e1.name_id,
  e2.simple_name                    AS name2,
  e2.name_id,
  tax_syn                           AS name2_synonym,
  e2.synonyms -> tax_syn ->> 'type' AS type
FROM tree_element e1, tree_element e2,
      jsonb_object_keys(e2.synonyms) AS tax_syn
WHERE
  e1.tree_version_id = 146
  AND e2.tree_version_id = 146
  AND e1.synonyms IS NOT NULL
  AND e2.tree_element_id <> e1.tree_element_id
  AND tax_syn = e1.simple_name
  AND e2.synonyms -> tax_syn ->> 'type' !~ '.*(misapp|pro parte|common).*';
----
